# If you simply want to test your command, use the --dry-run=client option.
# This will not create the resource. Instead, tell you whether the resource
# can be created and if your command is right.
# -o yaml: This will output the resource definition in YAML format on the screen.

## Rollout

# Apply new changes made to the deployment definition file
# A new rollout will be triggered
kubectl apply -f rolling-updates-and-rollbacks-in-deployments-definition.yaml

# Another approach through imperative command that will also trigger a rollout,
# but will left the definition file behind with an different configuration.
kubectl set image deployment/myapp-deployment nginx-container=nginx:1.9.1

# Get the status
kubectl rollout status deployment/myapp-deployment

# Get the history
kubectl rollout history deployment/myapp-deployment

# You can check the status of each revision individually by using the --revision flag:
kubectl rollout history deployment myapp-deployment --revision=1

# Using the --record flag:
# You would have noticed that the "change-cause" field is empty in the rollout
# history output. We can use the --record flag to save the command used 
# to create/update a deployment against the revision number.
kubectl set image deploy/myapp-deployment nginx-container=nginx:1.17 --record
kubectl rollout history deploy myapp-deployment

# To rollback to specific revision we will use the --to-revision flag.
# With --to-revision=1, it will be rolled back with the first image we used
# to create a deployment as we can see in the rollout history output.
kubectl rollout history deployment myapp-deployment --revision=1
kubectl rollout undo deployment myapp-deployment --to-revision=1

# Undo a rollout/change
# The deploy will destroy the pods generated by the new ReplicaSet and bring
# the other ones up in the old ReplicaSet. Your application will be back to its
# older format
kubectl rollout undo deployment/myapp-deployment
